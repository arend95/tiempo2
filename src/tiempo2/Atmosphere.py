"""!
@file
This file handles all atmospheric screen generation. 
In particular, the EPL maps from ARIS are converted to Gaussian-smoothed PWV maps.
"""

import glob
import os
import numpy as np
import pickle

from astropy.io import fits
from scipy.ndimage import gaussian_filter
from scipy.interpolate import RectBivariateSpline
from dataclasses import dataclass, field

def parser(line):
    """!
    Parser for reading atmospheric transmission curves from text file.

    @param line Line of text 
    """
    spline = line.split()
    return [float(el) for el in spline]

class Atmosphere:
    """!
    Class that represents atmosphere. Uses ARIS data to generate PWV matrix.

    This class handles generation of PWV maps from ARIS data. 
    It sets the path to the FITS files, sets the relevant parameters, such as map size, cell size, observation duration, and wind speed.
    Also, the chopper angular throw, scanned area on-sky and telescope elevation are set here.
    """

    #### TODO: Immediately convert to azimuth and elevation after Gaussian smoothing.
    #### Also, implement stepper function to call and update exposed mask with single increment along x-axis


    def __init__(self, prefix_filename, path_data, pwv0, pwvgrid, max_windspeed, obs_duration, dish_radius,
                max_num_strips=1, x_length_strip=0, OFFdist=233.6, Rscan=60., EL0=60., h_column=1000., load_spline=False):
        """!   
        Constructor for Atmosphere class.

        @param prefix_filename Prefix of FITS file generated by ARIS. Note that this value should not include the '000'
        @param path_data Absolute path to directory containing FITS file.
        @param pwv0 Mean PWV value around which dPWV is evaluated, in mm.
        @param pwvgrid Gridsize of a cell in PWV matrix, in m.
        @param max_windspeed Maximal windspeed of atmosphere, in m/s.
        @param obs_duration Total observation time, in s.
        @param dish_radius Radius of telescope primary aperture in meters.
        @param max_num_strips Maximal number of atmosphere strips along the y-axis. If more strips are given than number of cells along x-axis, the program automatically reduces this amount such that the number of strips along y equals the number of cells along x.
        @param x_length_strip Number of cells along x-axis.
        @param OFFdist Throw between chopper paths, in arcseconds.
        @param Rscan Radius of scanned area, in arcseconds.
        @param EL0 Central elevation angle, in degrees.
        @param h_column Reference height of atmospheric column, in meters.
        @param load_spline Use pre-computed smoothened PWV spline. If True, '.knots' and '.coeffs' files should exist at path_data + prefix_filename. Defaults to False.
        """
        self.prefix_filename =    prefix_filename
        self.path_data       =    path_data      
        self.pwv0            =    pwv0           
        self.pwvgrid         =    pwvgrid        
        self.max_windspeed   =    max_windspeed  
        self.obs_duration    =    obs_duration   
        self.dish_radius     =    dish_radius    
        self.max_num_strips  =    max_num_strips 
        self.x_length_strip  =    x_length_strip 
        self.OFFdist         =    OFFdist        
        self.Rscan           =    Rscan          
        self.EL0             =    EL0            
        self.h_column        =    h_column       
        self.load_spline     =    load_spline    
        
        flist = glob.glob( os.path.join(self.path_data, self.prefix_filename + '*.fits') )
        if len(flist):
            self.Loadfits = True
            print('Load fits files..')
        else:
            self.Loadfits = False
            print('Load text files..')

        # Conversion from dEPL to dPWV from Smith-Weintraub relation.
        a = 6.3003663 
       
        # Calculate maximum instantaneous offset given a chopper separation, radius of scanned area, and elevation. Value is in meters.
        maxoffset = np.tan(np.radians((self.OFFdist + self.Rscan)/3600.)) * self.h_column * np.cos(np.radians(self.EL0))

        # This is the necessary total length of a strip along the x-axis, in meters.
        max_distance = self.obs_duration * self.max_windspeed + maxoffset
        
        # Number of cells necessary along x-axis, given the cell size. Adjust number of strips to match max_x_index, if bigger.
        max_x_index = np.ceil( max_distance / self.pwvgrid )
        #num_strips = min( np.ceil(max_x_index / self.x_length_strip), self.max_num_strips )

        num_strips = int(max_num_strips)
        print(num_strips)
        # Interpolate on PWV_Gauss
        if not load_spline:
            print('Number of atmosphere strips loaded: ', num_strips)
            
            for i in range(num_strips):
                filename = self.prefix_filename + (3-len(str(i))) * "0" + str(i)
                if self.Loadfits:
                    hdul = fits.open(os.path.join(self.path_data, '%s.fits' %filename), memmap=True)
                    d = hdul[1].data
                else:
                    d = np.loadtxt(os.path.join(self.path_data, filename), delimiter=',')

                if i==0:
                    self.nx = int( max(d[:, 0]) ) + 1
                    self.ny = int( max(d[:, 1]) ) + 1
                print('dimensions atmosphere strips:')
                print(i, 'x: ', self.nx)
                print(i, 'y: ', self.ny)
                epl= np.zeros( [self.nx, self.ny] )

                for j in range(len(d)):
                    epl[ int(d[j, 0])-int(d[0, 0]), int(d[j, 1]) ] = int( d[j, 2] )

                if i == 0:
                    dEPL_matrix = epl[:, :] # 31 corresponds to y-direction: 31*pwvgrid (m)
                else:
                    dEPL_matrix = np.concatenate( (dEPL_matrix, epl[:, :]), axis=0)

                if self.Loadfits: hdul.close()
            self.PWV = self.pwv0 + (1./a * dEPL_matrix*1e-6)*1e+3 #in mm
            
            std = dish_radius/np.sqrt( 2.*np.log(10.) )
            truncate = dish_radius/std
           
            self.PWV_Gauss = gaussian_filter(self.PWV, std, mode='mirror', truncate=truncate)
            range_x = np.linspace(0, self.nx * pwvgrid, self.nx)
            range_y = np.linspace(0, self.ny * pwvgrid, self.ny)
            func = RectBivariateSpline(range_x, range_y, self.PWV_Gauss, kx=1, ky=1)
            self.func = func 
            self.atm_knots = func.get_knots()
            self.atm_coeffs = func.get_coeffs()

            path_save = os.path.join(self.path_data, self.prefix_filename)

            with open(f"{path_save}.knots", 'wb') as file:
                pickle.dump(func.get_knots(), file)
            with open(f"{path_save}.coeffs", 'wb') as file:
                pickle.dump(func.get_coeffs(), file)
            with open(f"{path_save}.shape", 'wb') as file:
                pickle.dump([self.nx, self.ny], file)

        else:
            path_save = os.path.join(self.path_data, self.prefix_filename)

            with open(f"{path_save}.knots", 'rb') as file:
                self.atm_knots = pickle.load(file)
            with open(f"{path_save}.coeffs", 'rb') as file:
                self.atm_coeffs = pickle.load(file)
            with open(f"{path_save}.shape", 'rb') as file:
                self.nx, self.ny = pickle.load(file)

        self.trans_knots = np.load(os.path.join(os.path.dirname(__file__), "resources", "atm_freq_pwv.knots"), allow_pickle=True)
        self.trans_coeffs = np.load(os.path.join(os.path.dirname(__file__), "resources", "atm_freq_pwv.coeffs"), allow_pickle=True)
